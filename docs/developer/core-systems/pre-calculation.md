---
sidebar_position: 5
---

# Pre-calculation and Caching Pipeline

The advanced pathfinding and TSP solving capabilities of Dungeons Guide are only possible because of an aggressive, multi-layered pre-calculation and caching pipeline. The system is designed to solve two major problems: the performance cost of real-time pathfinding, and the memory cost of loading huge amounts of pathfinding data.

This entire process happens **offline**, during development. The results are bundled with the mod release.

## The Overall Architecture

The system can be broken down into two distinct phases:

1.  **Offline Data Generation:** A developer-run process that calculates all the necessary data ahead of time and bundles it with the mod.
2.  **Runtime Cache Generation & Usage:** A just-in-time process that consolidates the pre-calculated data into an efficient in-memory cache for the solver to use.

---

## 1. Offline Data Generation

This phase happens entirely during development. It has two parts: calculating *where* a player needs to go, and calculating the *cost* to get there.

### A. Target Coordinate Calculation

Before a path can be calculated, the system needs to know the exact destination coordinates. This is handled by pre-calculating all valid target spots for an action based on the room's state.

-   **`PrecalculatedStonk`:** Calculates all valid standing locations for interacting with a specific block (e.g., clicking a lever), accounting for line-of-sight and potential blockers.
-   **`PrecalculatedMoveNearest`:** Calculates all valid standing locations near an entity or point (e.g., for killing a bat).

This data is generated by developers using the `calculatestonks` and `calculatenearests` debug commands and is stored within the main room data files.

### B. Path Cost Calculation (`PathfindPrecalculation`)

Once all possible targets are known, the expensive process of calculating the path costs between them begins.

-   **`PathfindPrecalculation`:** This object represents the raw, pre-calculated path cost data. Each `PathfindPrecalculation` corresponds to a single `.pfres2` file on disk and contains a lookup table of the costs to get from *every point* in a room to a *single target point*.
-   **The `PathfindRequest` System:** This is the system used by developers to generate new `.pfres2` files. A `PathfindPrecalculationRequestSet` bundles many pathfinding tasks into a zip file, which is uploaded to a remote server for heavy-duty processing, which then returns the generated `.pfres2` files.

---

## 2. Runtime Cache Generation & Usage

Loading hundreds of individual `.pfres2` files from disk at runtime would be slow and inefficient. To solve this, the system uses a just-in-time caching mechanism to consolidate this data.

### The `TSPCache` - A Just-in-Time Cache

The `TSPCache` is a critical performance component that is **built at runtime**. It is **not** an offline-built asset. Its purpose is to consolidate all the path cost data needed for a specific room configuration into a single, optimized, in-memory object.

### The `TSPCacheRegistry` and the Generation Process

1.  **Trigger:** The process is managed by the `TSPCacheRegistry`. The generation of a `TSPCache` is triggered whenever a `PathfindPreset` is loaded or a `RoomPreset` is modified by the user.

2.  **Scheduling:** When triggered, the registry schedules a `TSPCacheCalculationTask` to run on a background thread. This prevents the cache generation from causing any lag.

3.  **The Task:** The `TSPCacheCalculationTask` performs the following steps:
    -   It identifies the specific `RoomPreset` that needs its cache built.
    -   It reads the manifest of that `RoomPreset` to get the list of all required `PathfindPrecalculation` file IDs.
    -   It then reads all of these individual `.pfres2` files **from the disk**.
    -   It extracts the path cost data from each file and consolidates it all into a single, new `TSPCache` object.
    -   Finally, it serializes this new, complete `TSPCache` object and saves it to a single `.cache` file on disk for future sessions, and also stores it in an in-memory map for the current session.

### The Final Runtime Data Flow

1.  **Dungeon Start:** The `TSPCacheRegistry` is initialized. When a `PathfindPreset` is loaded, the registry checks if a `.cache` file for each room configuration already exists. If not, or if the configuration has changed, it schedules a background task to generate it.
2.  **Route Request:** The `ActionRoute` is created, which triggers the **[TSP Solver](./tsp-solver.md)**.
3.  **TSP Solve:** The TSP solver needs the cost between two actions. It asks the `RoomPresetPathPlanner`.
4.  **Instant Lookup:** The planner retrieves the fully populated `TSPCache` for the room from the `TSPCacheRegistry`. Since the cache is already consolidated and in-memory, it performs an instant lookup and returns the cost.

This architecture ensures that all expensive calculations (target-finding, pathfinding, and data consolidation) happen offline. At runtime, path costs are retrieved from a pre-built, in-memory cache, providing maximum performance with no disk I/O.